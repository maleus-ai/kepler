# Memory leak test config for status queries â€” exercises every Kepler feature
# Based on complex.kepler.yaml patterns.
# 15 services across 4 tiers.

lua: |
  _port = 9000
  function next_port()
    _port = _port + 1
    return tostring(_port)
  end
  function svc_env(name, extras)
    local env = {
      "SERVICE_NAME=" .. name,
      "SERVICE_PORT=" .. next_port()
    }
    if extras then
      for _, e in ipairs(extras) do
        table.insert(env, e)
      end
    end
    return env
  end

kepler:
  sys_env: inherit
  timeout: 30s
  logs:
    max_size: "1M"
    buffer_size: 4096
    retention:
      on_stop: clear
      on_start: clear
  hooks:
    pre_start:
      - if: "not ctx.initialized"
        run: echo "global on_init"
      - command: ["sh", "-c", "echo global pre_start"]
    post_start:
      run: echo "global post_start"

services:
  # TIER 1: Infrastructure
  postgres:
    command: ["sh", "-c", "echo PostgreSQL starting; exec sleep 300"]
    restart: always
    healthcheck:
      test: ["true"]
      interval: 1s
      timeout: 5s
      retries: 3
      start_period: 1s
    limits:
      memory: "512M"
      max_fds: 1024
    logs:
      buffer_size: 8192
      retention:
        on_stop: retain
        on_start: clear
    hooks:
      pre_start:
        - if: "not ctx.initialized"
          run: echo "postgres on_init"
      post_healthcheck_success:
        run: echo "postgres healthcheck passed"

  redis:
    command: ["sh", "-c", "echo Redis starting; exec sleep 300"]
    restart: always
    sys_env: clear
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s
    limits:
      memory: "256M"

  rabbitmq:
    command: ["sh", "-c", "echo RabbitMQ starting; exec sleep 300"]
    restart: always
    environment: !lua |
      return svc_env(ctx.service_name, {"AMQP_PORT=" .. next_port()})
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  # TIER 2: Setup
  db-migration:
    command: ["sh", "-c", "echo Running migrations; exit 0"]
    restart: no
    depends_on:
      postgres:
        condition: service_healthy

  redis-init:
    command: ["sh", "-c", "echo Initializing Redis; exit 0"]
    restart: no
    depends_on:
      redis:
        condition: service_healthy

  # TIER 3: Core
  auth-service:
    command: ["sh", "-c", "echo Auth service starting; exec sleep 300"]
    restart: always
    depends_on:
      - postgres:
          condition: service_healthy
          restart: true
      - redis:
          condition: service_healthy
      - db-migration:
          condition: service_completed_successfully
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s
    hooks:
      pre_start:
        - if: "not ctx.initialized"
          run: echo "auth on_init"
        - run: echo "auth pre_start"
      post_start:
        run: echo "auth post_start"

  event-bus:
    command: ["sh", "-c", "echo Event bus starting; exec sleep 300"]
    restart: always
    depends_on:
      - rabbitmq:
          condition: service_healthy
          restart: true
    healthcheck:
      test: !lua |
        return {"true"}
      interval: 1s
      retries: 3
      start_period: 1s

  gateway:
    command: ["sh", "-c", "echo Gateway starting; exec sleep 300"]
    restart: always
    depends_on:
      - auth-service:
          condition: service_healthy
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  # TIER 4: Business + Workers
  user-service:
    command: ["sh", "-c", "echo User service starting; exec sleep 300"]
    restart: always
    depends_on:
      - auth-service:
          condition: service_healthy
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  order-service:
    command: !lua |
      return {"sh", "-c", "echo Order service on port " .. next_port() .. "; exec sleep 300"}
    restart: always
    depends_on:
      - user-service:
          condition: service_started
      - event-bus:
          condition: service_healthy
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s
    limits:
      memory: "1G"

  notification-service:
    command: ["sh", "-c", "echo Notification starting; exec sleep 300"]
    restart: always
    depends_on: !lua |
      return {
        {["event-bus"] = {condition = "service_healthy"}},
        {["rabbitmq"] = {condition = "service_healthy"}}
      }
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  order-worker:
    command: ["sh", "-c", "echo Order worker started; exec sleep 300"]
    restart: always
    depends_on:
      - order-service:
          condition: service_started
      - event-bus:
          condition: service_healthy
    limits:
      memory: "256M"
      max_fds: 256
    logs:
      buffer_size: 16384

  analytics-service:
    command: ["sh", "-c", "echo Analytics starting; exec sleep 300"]
    restart: on-failure
    depends_on:
      - postgres:
          condition: service_healthy
      - event-bus:
          condition: service_healthy
      - redis-init:
          condition: service_completed_successfully
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  metrics-collector:
    command: ["sh", "-c", "echo Metrics starting; exec sleep 300"]
    restart: always
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s

  dashboard:
    command: !lua |
      return {"sh", "-c", "echo Dashboard on port " .. next_port() .. "; exec sleep 300"}
    restart: always
    depends_on:
      - metrics-collector:
          condition: service_started
      - gateway:
          condition: service_started
      - analytics-service:
          condition: service_started
    healthcheck:
      test: ["true"]
      interval: 1s
      retries: 3
      start_period: 1s
